-- // variables
local getService = game.GetService
local marketplaceService = getService(game, "MarketplaceService")
local teleportService = getService(game, "TeleportService")
local httpService = getService(game, "HttpService")
local players = getService(game, "Players")
local runService = getService(game, "RunService")
local workspace = getService(game, "Workspace")
local localPlayer = players.LocalPlayer
local osDate, mathRandom = os.date, math.random
local udim2New, color3FromRGB = UDim2.new, Color3.fromRGB
local vector2New, vector3New = Vector2.new, Vector3.new
local instanceNew = Instance.new
local currentCamera = workspace.CurrentCamera
local cframe = CFrame.new
local mathHuge = math.huge
local colorSequenceKeypoint = ColorSequenceKeypoint.new
local taskWait = task.wait

-- // esp framework
local framework = {}
do
	local espCache = {}
	local screenGui
	local mathFloor = math.floor
	
	-- Создаем ScreenGui один раз для всех ESP элементов
	local function initScreenGui()
		if not screenGui then
			screenGui = instanceNew("ScreenGui")
			screenGui.Name = "ESPScreenGui"
			screenGui.ResetOnSpawn = false
			screenGui.IgnoreGuiInset = true
			screenGui.Parent = localPlayer:WaitForChild("PlayerGui")
		end
		return screenGui
	end
	
	function framework:createBox(player)
		local character = player.Character
		if not character then return end
		
		local hrp = character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end
		
		local gui = initScreenGui()
		
		-- Создаем Frame для бокса
		local box = instanceNew("Frame")
		box.Name = "Box_" .. player.Name
		box.BackgroundTransparency = 1
		box.Size = udim2New(0, 100, 0, 100)
		box.Position = udim2New(0, 0, 0, 0)
		box.BorderSizePixel = 0
		box.Parent = gui
		
		-- Создаем UIStroke для обводки
		local stroke = instanceNew("UIStroke")
		stroke.Name = "Stroke"
		stroke.Thickness = 1.1
		stroke.Color = color3FromRGB(255, 255, 255)
		stroke.Parent = box
		
		-- Создаем UIGradient для градиента бокса
		local gradient = instanceNew("UIGradient")
		gradient.Name = "Gradient"
		gradient.Rotation = 90
		gradient.Color = ColorSequence.new({
			colorSequenceKeypoint(0, color3FromRGB(255, 255, 255)),
			colorSequenceKeypoint(0.33, color3FromRGB(255, 255, 255)),
			colorSequenceKeypoint(0.66, color3FromRGB(255, 255, 255)),
			colorSequenceKeypoint(1, color3FromRGB(255, 255, 255))
		})
		gradient.Parent = stroke
		
		-- Создаем outline (внешняя обводка)
		local outlineFrame = instanceNew("Frame")
		outlineFrame.Name = "OutlineFrame"
		outlineFrame.BackgroundTransparency = 1
		outlineFrame.Size = udim2New(1, 2, 1, 2)
		outlineFrame.Position = udim2New(0, -1, 0, -1)
		outlineFrame.BorderSizePixel = 0
		outlineFrame.Parent = box
		
		local outlineStroke = instanceNew("UIStroke")
		outlineStroke.Name = "OutlineStroke"
		outlineStroke.Thickness = 0.9
		outlineStroke.Color = color3FromRGB(0, 0, 0)
		outlineStroke.Parent = outlineFrame
		
		-- Создаем inline (внутренняя обводка)
		local inlineFrame = instanceNew("Frame")
		inlineFrame.Name = "InlineFrame"
		inlineFrame.BackgroundTransparency = 1
		inlineFrame.Size = udim2New(1, -2, 1, -2)
		inlineFrame.Position = udim2New(0, 1, 0, 1)
		inlineFrame.BorderSizePixel = 0
		inlineFrame.Parent = box
		
		local inlineStroke = instanceNew("UIStroke")
		inlineStroke.Name = "InlineStroke"
		inlineStroke.Thickness = 0.9
		inlineStroke.Color = color3FromRGB(0, 0, 0)
		inlineStroke.Parent = inlineFrame
		
		-- Создаем filled (фон бокса)
		local filledFrame = instanceNew("Frame")
		filledFrame.Name = "FilledFrame"
		filledFrame.BackgroundTransparency = 0.5
		filledFrame.BackgroundColor3 = color3FromRGB(0, 0, 0)
		filledFrame.BorderSizePixel = 0
		filledFrame.Size = udim2New(1, 0, 1, 0)
		filledFrame.Position = udim2New(0, 0, 0, 0)
		filledFrame.ZIndex = -1
		filledFrame.Visible = false
		filledFrame.Parent = box
		
		-- Outline для healthbar
		local healthBarOutline = instanceNew("Frame")
		healthBarOutline.Name = "HealthBarOutline_" .. player.Name
		healthBarOutline.BackgroundColor3 = color3FromRGB(0, 0, 0)
		healthBarOutline.BorderSizePixel = 0
		healthBarOutline.Visible = false
		healthBarOutline.Parent = gui
		
		local healthBarOutlineStroke = instanceNew("UIStroke")
		healthBarOutlineStroke.Name = "OutlineStroke"
		healthBarOutlineStroke.Thickness = 0.9
		healthBarOutlineStroke.Color = color3FromRGB(0, 0, 0)
		healthBarOutlineStroke.Parent = healthBarOutline
		
		-- Fill для healthbar
		local healthBarFill = instanceNew("Frame")
		healthBarFill.Name = "HealthBarFill"
		healthBarFill.BackgroundTransparency = 0
		healthBarFill.BorderSizePixel = 0
		healthBarFill.AnchorPoint = vector2New(0, 1)
		healthBarFill.Position = udim2New(0, 0, 1, 0)
		healthBarFill.Size = udim2New(1, 0, 1, 0)
		healthBarFill.Parent = healthBarOutline
		
		local healthBarGradient = instanceNew("UIGradient")
		healthBarGradient.Name = "HealthBarGradient"
		healthBarGradient.Rotation = 90
		healthBarGradient.Color = ColorSequence.new({
			colorSequenceKeypoint(0, color3FromRGB(0, 255, 0)),
			colorSequenceKeypoint(0.33, color3FromRGB(0, 255, 0)),
			colorSequenceKeypoint(0.66, color3FromRGB(0, 255, 0)),
			colorSequenceKeypoint(1, color3FromRGB(0, 255, 0))
		})
		healthBarGradient.Parent = healthBarFill
		
		return {
			player = player,
			box = box,
			stroke = stroke,
			gradient = gradient,
			outlineFrame = outlineFrame,
			outlineStroke = outlineStroke,
			inlineFrame = inlineFrame,
			inlineStroke = inlineStroke,
			filledFrame = filledFrame,
			character = character,
			healthBarOutline = healthBarOutline,
			healthBarOutlineStroke = healthBarOutlineStroke,
			healthBarFill = healthBarFill,
			healthBarGradient = healthBarGradient,
			lastHealth = 1
		}
	end
	
	function framework:removeBox(player)
		local espData = espCache[player]
		if espData then
			if espData.box then
				espData.box:Destroy()
			end
			if espData.healthBarOutline then
				espData.healthBarOutline:Destroy()
			end
		end
		espCache[player] = nil
	end
	
	function framework:updateBox(espData, flags)
		if not espData or not espData.character or not espData.box then return end
		
		local character = espData.character
		local hrp = character:FindFirstChild("HumanoidRootPart")
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		
		if not hrp then
			espData.box.Visible = false
			if espData.healthBarOutline then
				espData.healthBarOutline.Visible = false
			end
			return
		end
		
		-- Получаем позицию бокса на экране
		local boxPos, onScreen = currentCamera:WorldToViewportPoint(hrp.Position)
		
		if not onScreen then
			espData.box.Visible = false
			if espData.healthBarOutline then
				espData.healthBarOutline.Visible = false
			end
			return
		end
		
		-- Вычисляем размеры бокса через 8 углов
		local sizeX = 2.5
		local sizeY = 6
		local sizeZ = 1.5
		
		-- Все 8 углов 3D бокса
		local corners = {
			currentCamera:WorldToViewportPoint((hrp.CFrame * cframe(-sizeX/2, -sizeY/2, -sizeZ/2)).Position),
			currentCamera:WorldToViewportPoint((hrp.CFrame * cframe(sizeX/2, -sizeY/2, -sizeZ/2)).Position),
			currentCamera:WorldToViewportPoint((hrp.CFrame * cframe(-sizeX/2, sizeY/2, -sizeZ/2)).Position),
			currentCamera:WorldToViewportPoint((hrp.CFrame * cframe(sizeX/2, sizeY/2, -sizeZ/2)).Position),
			currentCamera:WorldToViewportPoint((hrp.CFrame * cframe(-sizeX/2, -sizeY/2, sizeZ/2)).Position),
			currentCamera:WorldToViewportPoint((hrp.CFrame * cframe(sizeX/2, -sizeY/2, sizeZ/2)).Position),
			currentCamera:WorldToViewportPoint((hrp.CFrame * cframe(-sizeX/2, sizeY/2, sizeZ/2)).Position),
			currentCamera:WorldToViewportPoint((hrp.CFrame * cframe(sizeX/2, sizeY/2, sizeZ/2)).Position)
		}
		
		-- Находим минимальные и максимальные координаты
		local minX, minY = math.huge, math.huge
		local maxX, maxY = -math.huge, -math.huge
		
		for i = 1, 8 do
			local corner = corners[i]
			minX = math.min(minX, corner.X)
			minY = math.min(minY, corner.Y)
			maxX = math.max(maxX, corner.X)
			maxY = math.max(maxY, corner.Y)
		end
		
		local boxWidth = maxX - minX
		local boxHeight = maxY - minY
		local boxX = minX
		local boxY = minY
		
		-- Сохраняем позицию для использования в healthbar (всегда, независимо от Box_Enabled)
		espData.lastBoxX = boxX
		espData.lastBoxY = boxY
		espData.lastBoxWidth = boxWidth
		espData.lastBoxHeight = boxHeight
		
		-- Обновляем бокс если включен
		local boxEnabled = flags and flags["Box_Enabled"] or false
		espData.box.Visible = boxEnabled
		if boxEnabled then
			espData.box.Position = udim2New(0, boxX, 0, boxY)
			espData.box.Size = udim2New(0, boxWidth, 0, boxHeight)
		end
		
		-- Обновляем healthbar если включен (используем сохраненные позиции)
		local healthEnabled = flags and flags["Health_Enabled"] or false
		if healthEnabled and humanoid and espData.healthBarFill and espData.healthBarOutline and espData.lastBoxX then
			local currentHealth = math.min(humanoid.Health / humanoid.MaxHealth, 1)
			local lastHealth = espData.lastHealth or currentHealth
			local lerpedHealth = lastHealth + (currentHealth - lastHealth) * 0.05
			espData.lastHealth = lerpedHealth
			
			-- Динамический offset в зависимости от расстояния
			local distance = (hrp.Position - currentCamera.CFrame.Position).Magnitude
			local baseOffset = 4.1
			local mathClamp = math.clamp or function(val, min, max) return math.max(min, math.min(max, val)) end
			local scaleFactor = mathClamp(1 + (distance / 100) * 0.2, 1, 1.2)
			local dynamicOffset = baseOffset * scaleFactor
			
			-- Толщина бара чуть тоньше
			local barWidth = 1.0
			
			-- Позиция healthbar слева от бокса (используем сохраненные значения)
			local barX = espData.lastBoxX - dynamicOffset - barWidth - 1
			local barY = espData.lastBoxY - 1
			local barHeight = espData.lastBoxHeight + 2
			
			espData.healthBarOutline.Position = udim2New(0, barX, 0, barY)
			espData.healthBarOutline.Size = udim2New(0, barWidth + 2, 0, barHeight)
			espData.healthBarOutline.Visible = true
			
			-- Обновляем видимость outline stroke
			if espData.healthBarOutlineStroke then
				local outlineEnabled = flags and flags["Health_Outline_Enabled"]
				if outlineEnabled ~= nil then
					espData.healthBarOutlineStroke.Enabled = outlineEnabled
				end
			end
			
			-- Заполнение healthbar снизу вверх
			espData.healthBarFill.Size = udim2New(1, 0, lerpedHealth, 0)
		else
			if espData.healthBarOutline then
				espData.healthBarOutline.Visible = false
			end
		end
	end
	
	function framework:getESP(player)
		return espCache[player]
	end
	
	function framework:setESP(player, espData)
		espCache[player] = espData
	end
	
	function framework:clearAll()
		for player, espData in pairs(espCache) do
			if espData.box then
				espData.box:Destroy()
			end
			if espData.healthBarOutline then
				espData.healthBarOutline:Destroy()
			end
		end
		espCache = {}
	end
	
	function framework:updateAllBoxes(flags)
		for player, espData in pairs(espCache) do
			framework:updateBox(espData, flags)
		end
	end
	
	function framework:applySettings(espData, flags)
		if not espData then return end
		
		-- Градиент
		if espData.gradient then
			local c1 = flags["Box_Color_1"] and flags["Box_Color_1"].Color or color3FromRGB(255, 255, 255)
			local c2 = flags["Box_Color_2"] and flags["Box_Color_2"].Color or color3FromRGB(255, 255, 255)
			local c3 = flags["Box_Color_3"] and flags["Box_Color_3"].Color or color3FromRGB(255, 255, 255)
			local c4 = flags["Box_Color_4"] and flags["Box_Color_4"].Color or color3FromRGB(255, 255, 255)
			espData.gradient.Color = ColorSequence.new({
				colorSequenceKeypoint(0, c1),
				colorSequenceKeypoint(0.33, c2),
				colorSequenceKeypoint(0.66, c3),
				colorSequenceKeypoint(1, c4)
			})
			if flags["Box_Gradient_Rotation"] then
				espData.gradient.Rotation = flags["Box_Gradient_Rotation"]
			end
		end
		
		-- Outline и inline
		if flags["Box_Outline_Color"] then
			espData.outlineStroke.Color = flags["Box_Outline_Color"].Color
			espData.inlineStroke.Color = flags["Box_Outline_Color"].Color
		end
		if flags["Box_Outline_Enabled"] ~= nil then
			espData.outlineFrame.Visible = flags["Box_Outline_Enabled"]
			espData.inlineFrame.Visible = flags["Box_Outline_Enabled"]
		end
		
		-- Filled
		if flags["Box_Filled_Enabled"] ~= nil then
			espData.filledFrame.Visible = flags["Box_Filled_Enabled"]
		end
		if flags["Box_Filled_Color"] then
			if flags["Box_Filled_Color"].Color then
				espData.filledFrame.BackgroundColor3 = flags["Box_Filled_Color"].Color
			end
			if flags["Box_Filled_Color"].Transparency ~= nil then
				espData.filledFrame.BackgroundTransparency = flags["Box_Filled_Color"].Transparency
			end
		end
		
		-- Healthbar
		if espData.healthBarGradient then
			local hc1 = flags["Health_Color_1"] and flags["Health_Color_1"].Color or color3FromRGB(0, 255, 0)
			local hc2 = flags["Health_Color_2"] and flags["Health_Color_2"].Color or color3FromRGB(0, 255, 0)
			local hc3 = flags["Health_Color_3"] and flags["Health_Color_3"].Color or color3FromRGB(0, 255, 0)
			local hc4 = flags["Health_Color_4"] and flags["Health_Color_4"].Color or color3FromRGB(0, 255, 0)
			espData.healthBarGradient.Color = ColorSequence.new({
				colorSequenceKeypoint(0, hc1),
				colorSequenceKeypoint(0.33, hc2),
				colorSequenceKeypoint(0.66, hc3),
				colorSequenceKeypoint(1, hc4)
			})
		end
		
		-- Healthbar outline
		if espData.healthBarOutlineStroke and flags["Health_Outline_Color"] then
			espData.healthBarOutlineStroke.Color = flags["Health_Outline_Color"].Color
		end
	end
end

-- // library initialization
do
	local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/loader/refs/heads/main/Library"))()
	local Window = Library:Window({
	    Name = "R4ze.pub rewrite",
	    Size = udim2New(0, 700, 0, 600),
	    FadeSpeed = 0.25
	})

	local Watermark = Library:Watermark("R4ze.pub rewrite | ".. osDate("%b %d %Y") .. " | ".. marketplaceService:GetProductInfo(game.PlaceId).Name)
	local KeybindList = Library:KeybindList()

	Watermark:SetVisibility(false)
	KeybindList:SetVisibility(false)
    local VisualsTab = Window:Page({Name = "Visuals", Columns = 2, Subtabs = false})
    local SettingsTab = Window:Page({Name = "Settings", Columns = 3, Subtabs = false})

	
	-- // visuals tab funcs and ui
	do
		-- ESP мультисекция с вкладками Box, Health, Armor, Flags
		local BoxSection, HealthSection, ArmorSection, FlagsSection = VisualsTab:MultiSection({
			Sections = {"Box", "Health", "Armor", "Flags"},
			Side = 1
		})
		
		-- Box вкладка
		do
			local boxToggle = BoxSection:Toggle({
				Name = "Box ESP",
				Default = false,
				Flag = "Box_Enabled",
				Callback = function(value)
					if value then
						-- Создаем ESP для всех игроков если его еще нет
						for _, player in pairs(players:GetPlayers()) do
							if player ~= localPlayer and player.Character then
								local espData = framework:getESP(player)
								if not espData then
									espData = framework:createBox(player)
									if espData then
										framework:setESP(player, espData)
										framework:applySettings(espData, Library.Flags)
									end
								end
							end
						end
					else
						-- Если Health ESP тоже выключен, удаляем все ESP
						if not Library.Flags["Health_Enabled"] then
							framework:clearAll()
						end
					end
				end
			})
			
			boxToggle:Colorpicker({
				Name = "Box Color 1",
				Default = color3FromRGB(255, 255, 255),
				Flag = "Box_Color_1",
				Callback = function(color)
					if not Library.Flags["Box_Enabled"] then return end
					-- Обновляем градиент для всех существующих ESP
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData and espData.gradient then
							local c2 = Library.Flags["Box_Color_2"] and Library.Flags["Box_Color_2"].Color or color3FromRGB(255, 255, 255)
							local c3 = Library.Flags["Box_Color_3"] and Library.Flags["Box_Color_3"].Color or color3FromRGB(255, 255, 255)
							local c4 = Library.Flags["Box_Color_4"] and Library.Flags["Box_Color_4"].Color or color3FromRGB(255, 255, 255)
							espData.gradient.Color = ColorSequence.new({
								colorSequenceKeypoint(0, color),
								colorSequenceKeypoint(0.33, c2),
								colorSequenceKeypoint(0.66, c3),
								colorSequenceKeypoint(1, c4)
							})
						end
					end
				end
			})
			
			boxToggle:Colorpicker({
				Name = "Box Color 2",
				Default = color3FromRGB(255, 255, 255),
				Flag = "Box_Color_2",
				Callback = function(color)
					if not Library.Flags["Box_Enabled"] then return end
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData and espData.gradient then
							local c1 = Library.Flags["Box_Color_1"] and Library.Flags["Box_Color_1"].Color or color3FromRGB(255, 255, 255)
							local c3 = Library.Flags["Box_Color_3"] and Library.Flags["Box_Color_3"].Color or color3FromRGB(255, 255, 255)
							local c4 = Library.Flags["Box_Color_4"] and Library.Flags["Box_Color_4"].Color or color3FromRGB(255, 255, 255)
							espData.gradient.Color = ColorSequence.new({
								colorSequenceKeypoint(0, c1),
								colorSequenceKeypoint(0.33, color),
								colorSequenceKeypoint(0.66, c3),
								colorSequenceKeypoint(1, c4)
							})
						end
					end
				end
			})
			
			boxToggle:Colorpicker({
				Name = "Box Color 3",
				Default = color3FromRGB(255, 255, 255),
				Flag = "Box_Color_3",
				Callback = function(color)
					if not Library.Flags["Box_Enabled"] then return end
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData and espData.gradient then
							local c1 = Library.Flags["Box_Color_1"] and Library.Flags["Box_Color_1"].Color or color3FromRGB(255, 255, 255)
							local c2 = Library.Flags["Box_Color_2"] and Library.Flags["Box_Color_2"].Color or color3FromRGB(255, 255, 255)
							local c4 = Library.Flags["Box_Color_4"] and Library.Flags["Box_Color_4"].Color or color3FromRGB(255, 255, 255)
							espData.gradient.Color = ColorSequence.new({
								colorSequenceKeypoint(0, c1),
								colorSequenceKeypoint(0.33, c2),
								colorSequenceKeypoint(0.66, color),
								colorSequenceKeypoint(1, c4)
							})
						end
					end
				end
			})
			
			boxToggle:Colorpicker({
				Name = "Box Color 4",
				Default = color3FromRGB(255, 255, 255),
				Flag = "Box_Color_4",
				Callback = function(color)
					if not Library.Flags["Box_Enabled"] then return end
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData and espData.gradient then
							local c1 = Library.Flags["Box_Color_1"] and Library.Flags["Box_Color_1"].Color or color3FromRGB(255, 255, 255)
							local c2 = Library.Flags["Box_Color_2"] and Library.Flags["Box_Color_2"].Color or color3FromRGB(255, 255, 255)
							local c3 = Library.Flags["Box_Color_3"] and Library.Flags["Box_Color_3"].Color or color3FromRGB(255, 255, 255)
							espData.gradient.Color = ColorSequence.new({
								colorSequenceKeypoint(0, c1),
								colorSequenceKeypoint(0.33, c2),
								colorSequenceKeypoint(0.66, c3),
								colorSequenceKeypoint(1, color)
							})
						end
					end
				end
			})
			
			BoxSection:Slider({
				Name = "Rotate",
				Min = 0,
				Max = 360,
				Decimals = 1,
				Default = 90,
				Flag = "Box_Gradient_Rotation",
				Callback = function(value)
					if not Library.Flags["Box_Enabled"] then return end
					-- Обновляем поворот градиента для всех существующих ESP
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData and espData.gradient then
							espData.gradient.Rotation = value
						end
					end
				end
			})
			
			local outlineToggle = BoxSection:Toggle({
				Name = "Box Outline",
				Default = true,
				Flag = "Box_Outline_Enabled",
				Callback = function(value)
					if not Library.Flags["Box_Enabled"] then return end
					-- Обновляем видимость outline и inline для всех существующих ESP
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData then
							if espData.outlineFrame then
								espData.outlineFrame.Visible = value
							end
							if espData.inlineFrame then
								espData.inlineFrame.Visible = value
							end
						end
					end
				end
			})
			
			outlineToggle:Colorpicker({
				Name = "Outline Color",
				Default = color3FromRGB(0, 0, 0),
				Flag = "Box_Outline_Color",
				Callback = function(color)
					if not Library.Flags["Box_Enabled"] then return end
					-- Обновляем цвет outline и inline для всех существующих ESP
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData then
							if espData.outlineStroke then
								espData.outlineStroke.Color = color
							end
							if espData.inlineStroke then
								espData.inlineStroke.Color = color
							end
						end
					end
				end
			})
			
			local filledToggle = BoxSection:Toggle({
				Name = "Filled",
				Default = false,
				Flag = "Box_Filled_Enabled",
				Callback = function(value)
					if not Library.Flags["Box_Enabled"] then return end
					-- Обновляем видимость filled для всех существующих ESP
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData and espData.filledFrame then
							espData.filledFrame.Visible = value
						end
					end
				end
			})
			
			filledToggle:Colorpicker({
				Name = "Filled Color",
				Default = color3FromRGB(0, 0, 0),
				Transparency = 0.5,
				Flag = "Box_Filled_Color",
				Callback = function(color, transparency)
					if not Library.Flags["Box_Enabled"] then return end
					-- Обновляем цвет и прозрачность filled для всех существующих ESP
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData and espData.filledFrame then
							espData.filledFrame.BackgroundColor3 = color
							espData.filledFrame.BackgroundTransparency = transparency
						end
					end
				end
			})
		end
		
		-- Health вкладка
		do
			local healthToggle = HealthSection:Toggle({
				Name = "Health Bar",
				Default = false,
				Flag = "Health_Enabled",
				Callback = function(value)
					if value then
						-- Создаем ESP для всех игроков если его еще нет
						for _, player in pairs(players:GetPlayers()) do
							if player ~= localPlayer and player.Character then
								local espData = framework:getESP(player)
								if not espData then
									espData = framework:createBox(player)
									if espData then
										framework:setESP(player, espData)
										framework:applySettings(espData, Library.Flags)
									end
								end
							end
						end
					else
						-- Если Box ESP тоже выключен, удаляем все ESP
						if not Library.Flags["Box_Enabled"] then
							framework:clearAll()
						else
							-- Если Box ESP включен, просто скрываем healthbar
							for _, player in pairs(players:GetPlayers()) do
								local espData = framework:getESP(player)
								if espData and espData.healthBarOutline then
									espData.healthBarOutline.Visible = false
								end
							end
						end
					end
				end
			})
			
			healthToggle:Colorpicker({
				Name = "Health Color 1",
				Default = color3FromRGB(0, 255, 0),
				Flag = "Health_Color_1",
				Callback = function(color)
					framework:applySettings(nil, Library.Flags)
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData then framework:applySettings(espData, Library.Flags) end
					end
				end
			})
			
			healthToggle:Colorpicker({
				Name = "Health Color 2",
				Default = color3FromRGB(0, 255, 0),
				Flag = "Health_Color_2",
				Callback = function(color)
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData then framework:applySettings(espData, Library.Flags) end
					end
				end
			})
			
			healthToggle:Colorpicker({
				Name = "Health Color 3",
				Default = color3FromRGB(0, 255, 0),
				Flag = "Health_Color_3",
				Callback = function(color)
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData then framework:applySettings(espData, Library.Flags) end
					end
				end
			})
			
			healthToggle:Colorpicker({
				Name = "Health Color 4",
				Default = color3FromRGB(0, 255, 0),
				Flag = "Health_Color_4",
				Callback = function(color)
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData then framework:applySettings(espData, Library.Flags) end
					end
				end
			})
			
			local outlineToggle = HealthSection:Toggle({
				Name = "Outline",
				Default = true,
				Flag = "Health_Outline_Enabled",
				Callback = function(value)
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData and espData.healthBarOutlineStroke then
							espData.healthBarOutlineStroke.Enabled = value
						end
					end
				end
			})
			
			outlineToggle:Colorpicker({
				Name = "Outline Color",
				Default = color3FromRGB(0, 0, 0),
				Flag = "Health_Outline_Color",
				Callback = function(color)
					for _, player in pairs(players:GetPlayers()) do
						local espData = framework:getESP(player)
						if espData then framework:applySettings(espData, Library.Flags) end
					end
				end
			})
		end
		
		-- Armor вкладка
		do
			-- UI элементы будут добавлены позже
		end
		
		-- Flags вкладка
		do
			-- UI элементы будут добавлены позже
		end
	end
	
	-- // settings tab funcs and ui
	do
		local SettingsSection = SettingsTab:Section({Name = "Settings", Side = 2})
		local ConfigsSection = SettingsTab:Section({Name = "Profiles", Side = 1})
		local GameSection = SettingsTab:Section({Name = "Game", Side = 3})
		
		-- Создаем colorpicker'ы для темы
		for Index, Value in Library.Theme do 
			SettingsSection:Label({Name = Index, Alignment = "Left"}):Colorpicker({ 
				Name = Index, 
				Default = Value, 
				Flag = "Theme"..Index
			})
		end

		SettingsSection:Label({Name = "Menu Keybind", Alignment = "Left"}):Keybind({Name = "Menu Keybind", Flag = "Menu Keybind", Default = Enum.KeyCode.RightControl, Mode = "Toggle", Callback = function(Value)
			Library.MenuKeybind = Library.Flags["Menu Keybind"].Key
		end})

		SettingsSection:Toggle({Name = "Watermark", Flag = "Watermark", Default = false, Callback = function(Value)
			Watermark:SetVisibility(Value)
		end})

		SettingsSection:Toggle({Name = "Keybind List", Flag = "Keybind List", Default = false, Callback = function(Value)
			KeybindList:SetVisibility(Value)
		end})

		SettingsSection:Dropdown({Name = "Tweening Style", Flag = "Tweening Style", Default = "Exponential", Items = {"Linear", "Sine", "Quad", "Cubic", "Quart", "Quint", "Exponential", "Circular", "Back", "Elastic", "Bounce"}, Callback = function(Value)
			Library.Tween.Style = Enum.EasingStyle[Value]
		end})

		SettingsSection:Dropdown({Name = "Tweening Direction", Flag = "Tweening Direction", Default = "Out", Items = {"In", "Out", "InOut"}, Callback = function(Value)
			Library.Tween.Direction = Enum.EasingDirection[Value]
		end})

		SettingsSection:Slider({Name = "Tweening Time", Min = 0, Max = 5, Default = 0.25, Decimals = 0.01, Flag = "Tweening Time", Callback = function(Value)
			Library.Tween.Time = Value
		end})

		SettingsSection:Button({Name = "Notification test", Callback = function()
			Library:Notification("This is a notification This is a notification This is a notification This is a notification", 5, color3FromRGB(mathRandom(0, 255), mathRandom(0, 255), mathRandom(0, 255)))
		end})

		SettingsSection:Button({Name = "Unload library", Callback = function()
			Library:Unload()
		end})

		local ConfigName 
		local ConfigSelected

		local ConfigsListbox = ConfigsSection:Listbox({Items = { }, Name = "Configs", Flag = "Configs List", Callback = function(Value)
			ConfigSelected = Value
		end})

		ConfigsSection:Textbox({Name = "Config Name", Placeholder = ". .", Flag = "Config Name", Callback = function(Value)
			ConfigName = Value
		end})

		ConfigsSection:Button({Name = "Create Config", Callback = function()
			if not isfile(Library.Folders.Configs .. "/" .. ConfigName .. ".json") then
				writefile(Library.Folders.Configs .. "/" .. ConfigName .. ".json", Library:GetConfig())

				Library:RefreshConfigsList(ConfigsListbox)
			else
				Library:Notification("Config '" .. ConfigName .. ".json' already exists", 3, color3FromRGB(255, 0, 0))
				return
			end
		end})

		ConfigsSection:Button({Name = "Load Config", Callback = function()
			if ConfigSelected then
				Library:LoadConfig(readfile(Library.Folders.Configs .. "/" .. ConfigSelected))
				for Index in Library.Theme do 
					local color = Library.Flags["Theme"..Index].Color
					Library.Theme[Index] = color
					Library:ChangeTheme(Index, color)
				end
			end
		end})

		ConfigsSection:Button({Name = "Delete Config", Callback = function()
			if ConfigSelected then
				Library:DeleteConfig(ConfigSelected)
				Library:RefreshConfigsList(ConfigsListbox)
			end
		end})

		ConfigsSection:Button({Name = "Save Config", Callback = function()
			if ConfigSelected then Library:SaveConfig(ConfigSelected) end
		end})

		ConfigsSection:Button({Name = "Refresh Configs", Callback = function()
			Library:RefreshConfigsList(ConfigsListbox)
		end})

		Library:RefreshConfigsList(ConfigsListbox)
		
		-- Game Section
		do
			GameSection:Button({Name = "Copy JobId", Callback = function() 
				setclipboard(game.JobId)
				Library:Notification("JobId copied to clipboard", 2, color3FromRGB(0, 255, 0))
			end})
			GameSection:Button({Name = "Copy GameID", Callback = function() 
				setclipboard(game.GameId)
				Library:Notification("GameID copied to clipboard", 2, color3FromRGB(0, 255, 0))
			end})
			GameSection:Button({Name = "Copy Join Script", Callback = function()
				setclipboard('game:GetService("TeleportService"):TeleportToPlaceInstance(' .. game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)')
				Library:Notification("Join script copied to clipboard", 2, color3FromRGB(0, 255, 0))
			end})
			GameSection:Button({Name = "Rejoin", Callback = function()
				Library:Notification("Rejoining server...", 2, color3FromRGB(255, 255, 0))
				teleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, localPlayer)
			end})
			GameSection:Button({Name = "Join New Server", Callback = function()
				local serverData = httpService:JSONDecode(game:HttpGetAsync("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"))
				local randomServer = serverData.data[mathRandom(1, #serverData.data)]
				if randomServer.playing <= Library.Flags["max_players"] then
					Library:Notification("Joining new server...", 2, color3FromRGB(255, 255, 0))
					teleportService:TeleportToPlaceInstance(game.PlaceId, randomServer.id)
				else
					Library:Notification("No suitable server found", 3, color3FromRGB(255, 0, 0))
				end
			end})
			GameSection:Slider({Name = "Max Players", Flag = "max_players", Min = 0, Max = 40, Default = 15, Decimals = 1})
		end
	end
	
	-- // esp connections
	do
		-- RenderStepped для обновления позиций боксов
		runService.RenderStepped:Connect(function()
			if Library.Flags["Box_Enabled"] or Library.Flags["Health_Enabled"] then
				framework:updateAllBoxes(Library.Flags)
			end
		end)
		
		-- Обработка новых игроков
		players.PlayerAdded:Connect(function(player)
			player.CharacterAdded:Connect(function(character)
				taskWait(0.5) -- Ждем загрузки персонажа
				if (Library.Flags["Box_Enabled"] or Library.Flags["Health_Enabled"]) and player ~= localPlayer then
					local espData = framework:createBox(player)
					if espData then
						framework:setESP(player, espData)
						framework:applySettings(espData, Library.Flags)
					end
				end
			end)
		end)
		
		-- Обработка выхода игроков
		players.PlayerRemoving:Connect(function(player)
			framework:removeBox(player)
		end)
		
		-- Обработка смены персонажа (смерть/респавн)
		players.PlayerAdded:Connect(function(player)
			if player ~= localPlayer then
				player.CharacterAdded:Connect(function(character)
					taskWait(0.5)
					if Library.Flags["Box_Enabled"] or Library.Flags["Health_Enabled"] then
						framework:removeBox(player)
						local espData = framework:createBox(player)
						if espData then
							framework:setESP(player, espData)
							framework:applySettings(espData, Library.Flags)
						end
					end
				end)
			end
		end)
		
		-- Обработка существующих игроков
		for _, player in pairs(players:GetPlayers()) do
			if player ~= localPlayer and player.Character then
				if Library.Flags["Box_Enabled"] or Library.Flags["Health_Enabled"] then
					local espData = framework:createBox(player)
					if espData then
						framework:setESP(player, espData)
						framework:applySettings(espData, Library.Flags)
					end
				end
				
				player.CharacterAdded:Connect(function(character)
					taskWait(0.5)
					if Library.Flags["Box_Enabled"] or Library.Flags["Health_Enabled"] then
						framework:removeBox(player)
						local espData = framework:createBox(player)
						if espData then
							framework:setESP(player, espData)
							framework:applySettings(espData, Library.Flags)
						end
					end
				end)
			end
		end
	end
end
