-- // Variables
local uis = game:GetService("UserInputService")
local players = game:GetService("Players")
local ws = game:GetService("Workspace")
local rs = game:GetService("ReplicatedStorage")
local http_service = game:GetService("HttpService")
local gui_service = game:GetService("GuiService")
local lighting = game:GetService("Lighting")
local run = game:GetService("RunService")
local stats = game:GetService("Stats")
local coregui = game:GetService("CoreGui")
local debris = game:GetService("Debris")
local tween_service = game:GetService("TweenService")
local sound_service = game:GetService("SoundService")

local vec2 = Vector2.new
local vec3 = Vector3.new
local dim2 = UDim2.new
local dim = UDim.new 
local rect = Rect.new
local cfr = CFrame.new
local empty_cfr = cfr()
local point_object_space = empty_cfr.PointToObjectSpace
local angle = CFrame.Angles
local dim_offset = UDim2.fromOffset

local color = Color3.new
local rgb = Color3.fromRGB
local hex = Color3.fromHex
local hsv = Color3.fromHSV
local rgbseq = ColorSequence.new
local rgbkey = ColorSequenceKeypoint.new
local numseq = NumberSequence.new
local numkey = NumberSequenceKeypoint.new

local camera = ws.CurrentCamera
local lp = players.LocalPlayer 
local mouse = lp:GetMouse() 
local gui_offset = gui_service:GetGuiInset().Y

local max = math.max 
local floor = math.floor 
local min = math.min 
local abs = math.abs 
local noise = math.noise
local rad = math.rad 
local random = math.random 
local pow = math.pow 
local sin = math.sin 
local pi = math.pi 
local tan = math.tan 
local atan2 = math.atan2 
local clamp = math.clamp 

local insert = table.insert 
local find = table.find 
local remove = table.remove
local concat = table.concat

-- // AutoBuy Variables
local task_wait = task.wait

-- // Silent Aimbot Variables
local drawing_new = Drawing.new
local hookmetamethod = hookmetamethod
local newcclosure = newcclosure
local getnamecallmethod = getnamecallmethod
local checkcaller = checkcaller
local game = game
local enum = Enum
local instance_new = Instance.new
local udim2_new = UDim2.new
local udim2_offset = UDim2.fromOffset

-- // Library
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/Library/refs/heads/main/v5"))()

-- // Utility Functions
do
    local utility = {}
    
    function utility:predict(targetPart, predictionX, predictionY)
        if not targetPart then return nil end
        local velocity = targetPart.Velocity or vec3(0, 0, 0)
        return targetPart.Position + vec3(
            velocity.X * predictionX,
            velocity.Y * predictionY,
            velocity.Z * predictionX
        )
    end
    
    function utility:isPlayerKO(player)
        if not player or not player.Character then return false end
        
        -- Проверяем K.O статус через BodyEffects
        local success, isKO = pcall(function()
            local playerInWorkspace = workspace.Players:FindFirstChild(player.Name)
            if playerInWorkspace and playerInWorkspace:FindFirstChild("BodyEffects") then
                local koEffect = playerInWorkspace.BodyEffects:FindFirstChild("K.O")
                if koEffect and koEffect:FindFirstChild("Value") then
                    return koEffect.Value.Value == true
                end
            end
            return false
        end)
        
        if success then
            return isKO
        end
        
        -- Fallback к проверке здоровья если BodyEffects недоступны
        local humanoid = player.Character:FindFirstChild("Humanoid")
        return humanoid and humanoid.Health <= 0
    end
    
    function utility:isPlayerGrabbed(player)
        if not player or not player.Character then return false end
        -- Проверяем, схвачен ли игрок
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            return humanoid.PlatformStand or false
        end
        return false
    end
    
    function utility:hasForceField(player)
        if not player or not player.Character then return false end
        return player.Character:FindFirstChildOfClass("ForceField") ~= nil
    end
    
    function utility:hasWallBetween(fromPosition, toPosition, targetPlayer)
        if not fromPosition or not toPosition or not targetPlayer then return false end
        
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        raycastParams.FilterDescendantsInstances = {targetPlayer.Character, lp.Character}
        
        local direction = (toPosition - fromPosition)
        
        local raycastResult = workspace:Raycast(fromPosition, direction, raycastParams)
        return raycastResult ~= nil
    end
    
    function utility:getClosestPlayer(fovRadius, targetPart, useFov, checks, predX, predY)
        local closestPlayer, closestDistance = nil, math.huge
        
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp and player.Character and player.Character:FindFirstChild(targetPart) then
                -- Проверки цели (только при выборе новой цели)
                local skipPlayer = false
                if checks then
                    if checks.checkKO and utility:isPlayerKO(player) then
                        skipPlayer = true
                    elseif checks.checkGrabbed and utility:isPlayerGrabbed(player) then
                        skipPlayer = true
                    elseif checks.checkForceField and utility:hasForceField(player) then
                        skipPlayer = true
                    elseif checks.checkWall and utility:hasWallBetween(camera.CFrame.Position, player.Character[targetPart].Position, player) then
                        skipPlayer = true
                    end
                end
                
                if not skipPlayer then
                    local part = player.Character[targetPart]
                    local predictedPosition = utility:predict(part, predX or 0.021111111, predY or 0.0102)
                    if predictedPosition then
                        local screenPos, onScreen = camera:WorldToViewportPoint(predictedPosition)
                        if onScreen then
                            local mousePos = uis:GetMouseLocation()
                            local distance = (vec2(screenPos.X, screenPos.Y) - mousePos).Magnitude
                            
                            if useFov then
                                if distance < fovRadius and distance < closestDistance then
                                    closestPlayer = part
                                    closestDistance = distance
                                end
                            else
                                if distance < closestDistance then
                                    closestPlayer = part
                                    closestDistance = distance
                                end
                            end
                        end
                    end
                end
            end
        end
        return closestPlayer
    end
    
    _G.silentUtility = utility
end

-- // AutoBuy Module
do
    local autoBuySettings = {
        autoArmor = {
            enabled = false,
            armorValue = 120,
            key = enum.KeyCode.F1,
            keyMode = "Toggle"
        },
        autoGuns = {
            enabled = false,
            selectedWeapons = {"[Rifle]", "[LMG]"},
            key = enum.KeyCode.F2,
            keyMode = "Toggle"
        },
        autoAmmo = {
            enabled = false,
            key = enum.KeyCode.F3,
            keyMode = "Toggle"
        }
    }
    
    -- Shop objects
    local Shop = ws.Ignored.Shop
    local ARMOR_SHOP = Shop["[High-Medium Armor] - $2513"]
    local ARMOR_PRICE = 2513
    
    -- Weapons data
    local WEAPONS = {
        {Name = "[Rifle]", ShopName = "[Rifle] - $0", Enabled = true},
        {Name = "[LMG]", ShopName = "[LMG] - $0", Enabled = true},
        {Name = "[P90]", ShopName = "[P90] - $0", Enabled = false},
        {Name = "[Flintlock]", ShopName = "[Flintlock] - $0", Enabled = false},
        {Name = "[Revolver]", ShopName = "[Revolver] - $0", Enabled = false},
        {Name = "[Double-Barrel SG]", ShopName = "[Double-Barrel SG] - $0", Enabled = false},
        {Name = "[AK47]", ShopName = "[AK47] - $0", Enabled = false},
        {Name = "[TacticalShotgun]", ShopName = "[TacticalShotgun] - $0", Enabled = false},
        {Name = "[SMG]", ShopName = "[SMG] - $0", Enabled = false},
        {Name = "[AR]", ShopName = "[AR] - $0", Enabled = false},
        {Name = "[Silencer]", ShopName = "[Silencer] - $0", Enabled = false},
        {Name = "[Shotgun]", ShopName = "[Shotgun] - $0", Enabled = false}
    }
    
    -- Ammo mapping
    local AMMO_MAP = {
        ["[Rifle]"] = "5 [Rifle Ammo] - $0",
        ["[LMG]"] = "200 [LMG Ammo] - $0",
        ["[P90]"] = "120 [P90 Ammo] - $0",
        ["[Flintlock]"] = "6 [Flintlock Ammo] - $0",
        ["[Revolver]"] = "12 [Revolver Ammo] - $0",
        ["[Double-Barrel SG]"] = "18 [Double-Barrel SG Ammo] - $0",
        ["[AK47]"] = "90 [AK47 Ammo] - $0",
        ["[TacticalShotgun]"] = "20 [TacticalShotgun Ammo] - $0",
        ["[SMG]"] = "80 [SMG Ammo] - $0",
        ["[AR]"] = "100 [AR Ammo] - $0",
        ["[Silencer]"] = "25 [Silencer Ammo] - $0",
        ["[Shotgun]"] = "20 [Shotgun Ammo] - $0"
    }
    
    -- Utility functions
    local autoBuyUtility = {}
    
    function autoBuyUtility:hasWeapon(weaponName)
        if lp.Backpack:FindFirstChild(weaponName) then
            return true
        end
        
        local character = lp.Character
        if character and character:FindFirstChild(weaponName) then
            return true
        end
        
        return false
    end
    
    function autoBuyUtility:getWeaponShop(weaponData)
        return Shop:FindFirstChild(weaponData.ShopName)
    end
    
    function autoBuyUtility:hasItem(itemName)
        local function check(container)
            for _, item in pairs(container:GetChildren()) do
                if item.Name == itemName then
                    return true
                end
            end
            return false
        end
        return check(lp.Backpack) or check(lp.Character)
    end
    
    function autoBuyUtility:getAmmoShop(ammoName)
        return Shop:FindFirstChild(ammoName)
    end
    
    -- Auto buy functions
    local function AutoArmor()
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") and lp.Character:FindFirstChild("BodyEffects") then
            local Origin = lp.Character.HumanoidRootPart.CFrame
            local Armor = lp.Character.BodyEffects.Armor
            
            if Armor.Value <= autoBuySettings.autoArmor.armorValue then
                repeat
                    task_wait()    
                    lp.Character.HumanoidRootPart.CFrame = ARMOR_SHOP.Head.CFrame
                    fireclickdetector(ARMOR_SHOP.ClickDetector)
                until Armor.Value >= 130 or lp.DataFolder.Currency.Value < ARMOR_PRICE
                lp.Character.HumanoidRootPart.CFrame = Origin
            end
        end
    end
    
    local function AutoAmmo(weaponName)
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            local ammoName = AMMO_MAP[weaponName]
            if not ammoName then return end
            
            local inventoryItem = lp.DataFolder.Inventory:FindFirstChild(weaponName)
            local currentAmmo = inventoryItem and tonumber(inventoryItem.Value) or 0
            
            if currentAmmo > 0 then
                return
            end
            
            for _, tool in pairs(lp.Character:GetChildren()) do
                if tool:IsA("Tool") then
                    tool.Parent = lp.Backpack
                end
            end
            
            local Origin = lp.Character.HumanoidRootPart.CFrame
            local ammoShop = autoBuyUtility:getAmmoShop(ammoName)
            
            if ammoShop and ammoShop:FindFirstChild("Head") and ammoShop:FindFirstChild("ClickDetector") then
                for i = 1, 2 do
                    local startAmmo = lp.DataFolder.Inventory:FindFirstChild(weaponName)
                    local startValue = startAmmo and tonumber(startAmmo.Value) or 0
                    
                    repeat
                        task_wait()
                        lp.Character.HumanoidRootPart.CFrame = ammoShop.Head.CFrame
                        fireclickdetector(ammoShop.ClickDetector)
                        
                        local newAmmo = lp.DataFolder.Inventory:FindFirstChild(weaponName)
                        local newValue = newAmmo and tonumber(newAmmo.Value) or 0
                    until newValue > startValue
                end
                
                lp.Character.HumanoidRootPart.CFrame = Origin
            end
        end
    end
    
    local function AutoWeaponsAndAmmo()
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            for _, weaponData in ipairs(WEAPONS) do
                if weaponData.Enabled then
                
                if not autoBuyUtility:hasWeapon(weaponData.Name) then
                    local s, e = pcall(function()
                        local Origin = lp.Character.HumanoidRootPart.CFrame
                        local weaponShop = autoBuyUtility:getWeaponShop(weaponData)
                        
                        if weaponShop and weaponShop:FindFirstChild("Head") and weaponShop:FindFirstChild("ClickDetector") then
                            repeat
                                task_wait()
                                lp.Character.HumanoidRootPart.CFrame = weaponShop.Head.CFrame
                                fireclickdetector(weaponShop.ClickDetector)
                            until autoBuyUtility:hasWeapon(weaponData.Name)
                            
                            lp.Character.HumanoidRootPart.CFrame = Origin
                        end
                    end)
                    if not s then warn("[AutoBuy] Weapon buy error:", weaponData.Name, e) end
                end
                
                if autoBuyUtility:hasWeapon(weaponData.Name) then
                    local s, e = pcall(AutoAmmo, weaponData.Name)
                    if not s then warn("[AutoBuy] Ammo buy error:", weaponData.Name, e) end
                end
                end
            end
        end
    end
    
    -- Main loop
    local function MainAutoBuy()
        while task_wait() do
            if autoBuySettings.autoArmor.enabled then
                local s, e = pcall(AutoArmor)
                if not s then warn("[AutoBuy] Armor error:", e) end
            end
            
            if (autoBuySettings.autoGuns.enabled or autoBuySettings.autoAmmo.enabled) and lp.Character and lp.Character:FindFirstChild("BodyEffects") then
                local Armor = lp.Character.BodyEffects.Armor
                if Armor.Value >= 130 then
                    if autoBuySettings.autoGuns.enabled then
                        local s2, e2 = pcall(AutoWeaponsAndAmmo)
                        if not s2 then warn("[AutoBuy] weapons/ammo error:", e2) end
                    elseif autoBuySettings.autoAmmo.enabled then
                        -- Auto ammo only for existing weapons
                        for _, weaponData in ipairs(WEAPONS) do
                            if autoBuyUtility:hasWeapon(weaponData.Name) then
                                local s3, e3 = pcall(AutoAmmo, weaponData.Name)
                                if not s3 then warn("[AutoBuy] Ammo buy error:", weaponData.Name, e3) end
                            end
                        end
                    end
                end
            end
        end
    end
    
    _G.autoBuySettings = autoBuySettings
    _G.autoBuyUtility = autoBuyUtility
    _G.MainAutoBuy = MainAutoBuy
    _G.WEAPONS = WEAPONS
    
    -- Start main loop
    coroutine.resume(coroutine.create(MainAutoBuy))
end

-- // Window
local window = library:window({
    name = "R4ZE", 
    suffix = ".PUB", 
    gameInfo = "Raze.pub v3"
})

-- // Combat Tab
do
    local CameraBotTab, SilentBotTab = window:tab({
        name = "Combat", 
        icon = "rbxassetid://10734975692",  -- lucide-target
        tabs = {"CameraBot", "SilentBot"}
    })
    
    -- CameraBot Section
    do
        local CameraBotSection = CameraBotTab:column({})
        local section = CameraBotSection:section({name = "CameraBot", default = false})
        
        -- Camera Aimbot Implementation
        do
            -- Camera Aimbot Variables
            local cameraSettings = {
                enabled = false,
                stickyTarget = nil,
                stickyEnabled = false,
                targetPart = "Head",
                aimlockType = "Mouse Movement",
                -- Prediction settings
                predictionEnabled = false,
                customPredictionX = 0.021111111,
                customPredictionY = 0.0102,
                -- Resolver settings
                resolverEnabled = false,
                resolverMode = "Velocity",
                -- Checks settings
                checksEnabled = false,
                checkKO = false,
                checkGrabbed = false,
                checkForceField = false,
                checkWall = false
            }
            
            -- Helper Functions
            local function MouseMover(X, Y)
                mousemoverel(X, Y)    
            end
            
            local function getCameraTarget()
                if cameraSettings.stickyEnabled then
                    if cameraSettings.stickyTarget and cameraSettings.stickyTarget.Parent then
                        return cameraSettings.stickyTarget
                    else
                        -- Захватываем новую цель если sticky включен
                        local checks = cameraSettings.checksEnabled and {
                            checkKO = cameraSettings.checkKO,
                            checkGrabbed = cameraSettings.checkGrabbed,
                            checkForceField = cameraSettings.checkForceField,
                            checkWall = cameraSettings.checkWall
                        } or nil
                        local predX = cameraSettings.predictionEnabled and cameraSettings.customPredictionX or 0
                        local predY = cameraSettings.predictionEnabled and cameraSettings.customPredictionY or 0
                        cameraSettings.stickyTarget = _G.silentUtility:getClosestPlayer(math.huge, cameraSettings.targetPart, false, checks, predX, predY)
                        return cameraSettings.stickyTarget
                    end
                else
                    cameraSettings.stickyTarget = nil
                    return nil
                end
            end
            
            -- Main Camera Aimbot Toggle
            local mainToggle = section:toggle({
                name = "Camera Aimbot", 
                flag = "camera_enabled",
                type = "toggle",
                callback = function(bool)
                    cameraSettings.enabled = bool
                    if not bool then
                        cameraSettings.stickyTarget = nil
                    end
                end,
                seperator = true
            })
            
            -- Sticky Target Keybind  
            section:keybind({
                name = "Sticky Target",
                flag = "camera_sticky_key", 
                key = enum.KeyCode.T,
                mode = "Toggle",
                default = false,
                callback = function(active)
                    cameraSettings.stickyEnabled = active
                end,
                seperator = true
            })
            
            -- Aimlock Type Dropdown
            section:dropdown({
                name = "Aimlock Type",
                flag = "camera_aimlock_type",
                items = {
                    "Mouse Movement",
                    "MoveCenterOfScreen"
                },
                default = "Mouse Movement",
                callback = function(selected)
                    cameraSettings.aimlockType = selected
                end,
                seperator = true
            })
            
            -- Prediction Toggle
            local predictionToggle = section:toggle({
                name = "Prediction", 
                flag = "camera_prediction_enabled",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.predictionEnabled = bool
                end,
                seperator = true
            })
            
            -- Prediction Settings Sub-section
            local predictionSubSection = predictionToggle:settings({})
            
            -- Prediction X Textbox
            predictionSubSection:textbox({
                name = "Prediction X",
                flag = "camera_prediction_x",
                placeholder = "0.021111111",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        cameraSettings.customPredictionX = value
                    end
                end,
                seperator = true
            })
            
            -- Prediction Y Textbox
            predictionSubSection:textbox({
                name = "Prediction Y",
                flag = "camera_prediction_y",
                placeholder = "0.0102",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        cameraSettings.customPredictionY = value
                    end
                end,
                seperator = true
            })
            
            -- Resolver Toggle
            local resolverToggle = section:toggle({
                name = "Resolver", 
                flag = "camera_resolver_enabled",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.resolverEnabled = bool
                end,
                seperator = true
            })
            
            -- Resolver Settings Sub-section
            local resolverSubSection = resolverToggle:settings({})
            
            -- Resolver Mode Dropdown
            resolverSubSection:dropdown({
                name = "Resolver Mode",
                flag = "camera_resolver_mode",
                items = {
                    "Velocity",
                    "MoveDirection", 
                    "CalculateCFrame"
                },
                default = "Velocity",
                callback = function(selected)
                    cameraSettings.resolverMode = selected
                end,
                seperator = true
            })
            
            -- Hitparts Dropdown
            section:dropdown({
                name = "Hitparts",
                flag = "camera_hitparts",
                items = {
                    "Head",
                    "UpperTorso", 
                    "LowerTorso",
                    "LeftUpperArm",
                    "LeftLowerArm",
                    "LeftHand",
                    "RightUpperArm",
                    "RightLowerArm", 
                    "RightHand",
                    "LeftUpperLeg",
                    "LeftLowerLeg",
                    "LeftFoot",
                    "RightUpperLeg",
                    "RightLowerLeg",
                    "RightFoot"
                },
                default = "Head",
                callback = function(selected)
                    cameraSettings.targetPart = selected
                end,
                seperator = true
            })
            
            -- Checks Toggle
            local checksToggle = section:toggle({
                name = "Checks", 
                flag = "camera_checks_enabled",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checksEnabled = bool
                end,
                seperator = true
            })
            
            -- Checks Settings Sub-section
            local checksSubSection = checksToggle:settings({})
            
            -- KO Check
            checksSubSection:toggle({
                name = "Check K.O",
                flag = "camera_check_ko",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checkKO = bool
                end,
                seperator = true
            })
            
            -- Grabbed Check
            checksSubSection:toggle({
                name = "Check Grabbed",
                flag = "camera_check_grabbed",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checkGrabbed = bool
                end,
                seperator = true
            })
            
            -- ForceField Check
            checksSubSection:toggle({
                name = "Check ForceField",
                flag = "camera_check_forcefield",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checkForceField = bool
                end,
                seperator = true
            })
            
            -- Wall Check
            checksSubSection:toggle({
                name = "Check Wall",
                flag = "camera_check_wall",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checkWall = bool
                end,
                seperator = true
            })
            
            -- Camera Aimbot Loop
            run.RenderStepped:Connect(function()
                if not cameraSettings.enabled then
                    return
                end
                
                local target = getCameraTarget()
                if target then
                    -- Используем prediction если включен
                    local targetPosition = target.Position
                    if cameraSettings.predictionEnabled then
                        local predX = cameraSettings.customPredictionX
                        local predY = cameraSettings.customPredictionY
                        targetPosition = _G.silentUtility:predict(target, predX, predY) or target.Position
                    end
                    
                    local screenPos, onScreen = camera:WorldToViewportPoint(targetPosition)
                    
                    if onScreen then
                        if cameraSettings.aimlockType == "Mouse Movement" then
                            local mousePos = uis:GetMouseLocation()
                            local deltaX = screenPos.X - mousePos.X
                            local deltaY = screenPos.Y - mousePos.Y
                            
                            -- Перемещаем курсор к цели
                            MouseMover(deltaX, deltaY)
                            
                        elseif cameraSettings.aimlockType == "MoveCenterOfScreen" then
                            local screenSize = camera.ViewportSize
                            local centerX = screenSize.X / 2
                            local centerY = screenSize.Y / 2
                            
                            local deltaX = screenPos.X - centerX
                            local deltaY = screenPos.Y - centerY
                            
                            -- Двигаем камеру чтобы цель была в центре экрана
                            local currentCFrame = camera.CFrame
                            local lookDirection = (targetPosition - currentCFrame.Position).Unit
                            camera.CFrame = cfr(currentCFrame.Position, currentCFrame.Position + lookDirection)
                        end
                    end
                end
            end)
            
        end
    end
    
    -- SilentBot Section  
    do
        local SilentBotSection = SilentBotTab:column({})
        local section = SilentBotSection:section({name = "SilentBot", default = false})
        
        -- Silent Aimbot Implementation
        do
            -- Silent Aimbot Variables
            local silentSettings = {
                enabled = false,
                stickyTarget = nil,
                fovRadius = 350,
                targetPart = "Head",
                useFov = true,
                showFov = true,
                fovColor = rgb(0, 169, 255),
                fovTransparency = 0.5,
                predictionX = 0.021111111,
                predictionY = 0.0102,
                stickyKey = enum.KeyCode.C,
                -- Visualise settings
                visualiseEnabled = false,
                highlightEnabled = false,
                highlightFillColor = rgb(0, 169, 255),
                highlightFillTransparency = 0.5,
                highlightOutlineColor = rgb(0, 169, 255),
                highlightOutlineTransparency = 0.5,
                tracerEnabled = false,
                tracerColor = rgb(0, 169, 255),
                tracerTransparency = 0.5,
                -- Checks settings
                checksEnabled = false,
                checkKO = false,
                checkGrabbed = false,
                checkForceField = false,
                checkWall = false,
                -- Prediction settings
                predictionEnabled = false,
                customPredictionX = 0.021111111,
                customPredictionY = 0.0102,
                -- Resolver settings
                resolverEnabled = false,
                resolverMode = "Velocity",
                -- Sticky settings
                stickyEnabled = false
            }
            
            -- ScreenGui FOV Circle
            local screenGui = instance_new("ScreenGui")
            screenGui.Name = "SilentAimbotFOV"
            screenGui.Parent = coregui
            
            local fovFrame = instance_new("Frame")
            fovFrame.Name = "FOVCircle"
            fovFrame.BackgroundTransparency = 1
            fovFrame.BorderSizePixel = 0
            fovFrame.Size = udim2_offset(silentSettings.fovRadius * 2, silentSettings.fovRadius * 2)
            fovFrame.Position = udim2_offset(0, 0)
            fovFrame.AnchorPoint = vec2(0.5, 0.5)
            fovFrame.Visible = false
            fovFrame.Parent = screenGui
            
            local fovCircle = instance_new("UIStroke")
            fovCircle.Thickness = 2
            fovCircle.Color = silentSettings.fovColor
            fovCircle.Transparency = silentSettings.fovTransparency
            fovCircle.Parent = fovFrame
            
            local fovCorner = instance_new("UICorner")
            fovCorner.CornerRadius = dim(0.5, 0)
            fovCorner.Parent = fovFrame
            
            local esp = nil
            local tracerLine = drawing_new("Line")
            tracerLine.Thickness = 2
            tracerLine.Color = silentSettings.tracerColor
            tracerLine.Transparency = silentSettings.tracerTransparency
            tracerLine.Visible = false
            
            -- Helper Functions
            local function highlightPlayer(target)
                if not silentSettings.visualiseEnabled or not silentSettings.highlightEnabled then
                    return
                end
                
                if esp then esp:Destroy() end
                esp = instance_new("Highlight")
                esp.Adornee = target.Parent
                esp.FillColor = silentSettings.highlightFillColor
                esp.OutlineColor = silentSettings.highlightOutlineColor
                esp.FillTransparency = silentSettings.highlightFillTransparency
                esp.OutlineTransparency = silentSettings.highlightOutlineTransparency
                esp.Parent = target.Parent
            end
            
            local function updateTracer(targetPosition)
                if not silentSettings.visualiseEnabled or not silentSettings.tracerEnabled then
                    tracerLine.Visible = false
                    return
                end
                
                if targetPosition then
                    tracerLine.Visible = true
                    tracerLine.From = uis:GetMouseLocation()
                    local screenPos, onScreen = camera:WorldToViewportPoint(targetPosition)
                    if onScreen then
                        tracerLine.To = vec2(screenPos.X, screenPos.Y)
                    else
                        tracerLine.Visible = false
                    end
                else
                    tracerLine.Visible = false
                end
            end
            
            local function destroyVisuals()
                if esp then esp:Destroy() end
                esp = nil
                tracerLine.Visible = false
            end
            
            local function getTarget()
                if silentSettings.stickyEnabled then
                    if silentSettings.stickyTarget and silentSettings.stickyTarget.Parent then
                        return silentSettings.stickyTarget
                    else
                        -- Захватываем новую цель если sticky включен
                        local checks = silentSettings.checksEnabled and {
                            checkKO = silentSettings.checkKO,
                            checkGrabbed = silentSettings.checkGrabbed,
                            checkForceField = silentSettings.checkForceField,
                            checkWall = silentSettings.checkWall
                        } or nil
                        local predX = silentSettings.predictionEnabled and silentSettings.customPredictionX or silentSettings.predictionX
                        local predY = silentSettings.predictionEnabled and silentSettings.customPredictionY or silentSettings.predictionY
                        silentSettings.stickyTarget = _G.silentUtility:getClosestPlayer(silentSettings.fovRadius, silentSettings.targetPart, silentSettings.useFov, checks, predX, predY)
                        return silentSettings.stickyTarget
                    end
                else
                    silentSettings.stickyTarget = nil
                    -- Свободный захват цели
                    local checks = silentSettings.checksEnabled and {
                        checkKO = silentSettings.checkKO,
                        checkGrabbed = silentSettings.checkGrabbed,
                        checkForceField = silentSettings.checkForceField,
                        checkWall = silentSettings.checkWall
                    } or nil
                    local predX = silentSettings.predictionEnabled and silentSettings.customPredictionX or silentSettings.predictionX
                    local predY = silentSettings.predictionEnabled and silentSettings.customPredictionY or silentSettings.predictionY
                    return _G.silentUtility:getClosestPlayer(silentSettings.fovRadius, silentSettings.targetPart, silentSettings.useFov, checks, predX, predY)
                end
            end
            
            -- Main Silent Aimbot Toggle
            local mainToggle = section:toggle({
                name = "Silent Aimbot", 
                flag = "silent_enabled",
                type = "toggle",
                callback = function(bool)
                    silentSettings.enabled = bool
                    if not bool then
                        destroyVisuals()
                        fovFrame.Visible = false
                    end
                end,
                seperator = true
            })
            
            -- Sticky Target Keybind  
            section:keybind({
                name = "Sticky Target",
                flag = "silent_sticky_key", 
                key = enum.KeyCode.C,
                mode = "Toggle",
                default = false,
                callback = function(active)
                    silentSettings.stickyEnabled = active
                end,
                seperator = true
            })
            
            -- FOV Toggle
            local fovToggle = section:toggle({
                name = "FOV", 
                flag = "silent_fov_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.useFov = bool
                end,
                seperator = true
            })
            
            -- FOV Settings Sub-section
            local fovSubSection = fovToggle:settings({})
            
            fovSubSection:slider({
                name = "FOV Size", 
                flag = "silent_fov_size",
                min = 50, 
                max = 500, 
                default = 350, 
                interval = 1,
                callback = function(value)
                    silentSettings.fovRadius = value
                    fovFrame.Size = udim2_offset(value * 2, value * 2)
                end,
                seperator = true
            })
            
            local showFovToggle = fovSubSection:toggle({
                name = "Show FOV", 
                flag = "silent_show_fov",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.showFov = bool
                    if not bool then
                        fovFrame.Visible = false
                    end
                end,
                seperator = true
            })
            
            showFovToggle:colorpicker({
                name = "FOV Color",
                flag = "silent_fov_color",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.fovColor = color
                    silentSettings.fovTransparency = transparency
                    fovCircle.Color = color
                    fovCircle.Transparency = transparency
                end
            })
            
            -- Visualise Toggle
            local visualiseToggle = section:toggle({
                name = "Visualise", 
                flag = "silent_visualise_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.visualiseEnabled = bool
                    if not bool then
                        destroyVisuals()
                    end
                end,
                seperator = true
            })
            
            -- Visualise Settings Sub-section
            local visualiseSubSection = visualiseToggle:settings({})
            
            -- Highlight Toggle
            local highlightToggle = visualiseSubSection:toggle({
                name = "Highlight", 
                flag = "silent_highlight_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.highlightEnabled = bool
                    if not bool and esp then
                        esp:Destroy()
                        esp = nil
                    end
                end,
                seperator = true
            })
            
            highlightToggle:colorpicker({
                name = "Fill Color",
                flag = "silent_highlight_fill",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.highlightFillColor = color
                    silentSettings.highlightFillTransparency = transparency
                    if esp then
                        esp.FillColor = color
                        esp.FillTransparency = transparency
                    end
                end
            })
            
            highlightToggle:colorpicker({
                name = "Outline Color",
                flag = "silent_highlight_outline",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.highlightOutlineColor = color
                    silentSettings.highlightOutlineTransparency = transparency
                    if esp then
                        esp.OutlineColor = color
                        esp.OutlineTransparency = transparency
                    end
                end
            })
            
            -- Tracer Toggle
            local tracerToggle = visualiseSubSection:toggle({
                name = "Tracer", 
                flag = "silent_tracer_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.tracerEnabled = bool
                    if not bool then
                        tracerLine.Visible = false
                    end
                end,
                seperator = true
            })
            
            tracerToggle:colorpicker({
                name = "Tracer Color",
                flag = "silent_tracer_color",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.tracerColor = color
                    -- Для Drawing API: больше fade = меньше прозрачности (инвертируем)
                    silentSettings.tracerTransparency = 1 - transparency
                    tracerLine.Color = color
                    tracerLine.Transparency = 1 - transparency
                end
            })
            
            -- Aimpart Dropdown
            section:dropdown({
                name = "Aimpart",
                flag = "silent_aimpart",
                items = {
                    "Head",
                    "UpperTorso", 
                    "LowerTorso",
                    "LeftUpperArm",
                    "LeftLowerArm",
                    "LeftHand",
                    "RightUpperArm",
                    "RightLowerArm", 
                    "RightHand",
                    "LeftUpperLeg",
                    "LeftLowerLeg",
                    "LeftFoot",
                    "RightUpperLeg",
                    "RightLowerLeg",
                    "RightFoot"
                },
                default = "Head",
                callback = function(selected)
                    silentSettings.targetPart = selected
                end,
                seperator = true
            })
            
            
            -- Checks Toggle
            local checksToggle = section:toggle({
                name = "Checks", 
                flag = "silent_checks_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checksEnabled = bool
                end,
                seperator = true
            })
            
            -- Checks Settings Sub-section
            local checksSubSection = checksToggle:settings({})
            
            -- KO Check
            checksSubSection:toggle({
                name = "Check K.O",
                flag = "silent_check_ko",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkKO = bool
                end,
                seperator = true
            })
            
            -- Grabbed Check
            checksSubSection:toggle({
                name = "Check Grabbed",
                flag = "silent_check_grabbed",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkGrabbed = bool
                end,
                seperator = true
            })
            
            -- ForceField Check
            checksSubSection:toggle({
                name = "Check ForceField",
                flag = "silent_check_forcefield",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkForceField = bool
                end,
                seperator = true
            })
            
            -- Wall Check
            checksSubSection:toggle({
                name = "Check Wall",
                flag = "silent_check_wall",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkWall = bool
                end,
                seperator = true
            })
            
            -- Prediction Toggle
            local predictionToggle = section:toggle({
                name = "Prediction", 
                flag = "silent_prediction_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.predictionEnabled = bool
                end,
                seperator = true
            })
            
            -- Prediction Settings Sub-section
            local predictionSubSection = predictionToggle:settings({})
            
            -- Prediction X Textbox
            predictionSubSection:textbox({
                name = "Prediction X",
                flag = "silent_prediction_x",
                placeholder = "0.021111111",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        silentSettings.customPredictionX = value
                    end
                end,
                seperator = true
            })
            
            -- Prediction Y Textbox
            predictionSubSection:textbox({
                name = "Prediction Y",
                flag = "silent_prediction_y",
                placeholder = "0.0102",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        silentSettings.customPredictionY = value
                    end
                end,
                seperator = true
            })
            
            -- Resolver Toggle
            local resolverToggle = section:toggle({
                name = "Resolver", 
                flag = "silent_resolver_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.resolverEnabled = bool
                end,
                seperator = true
            })
            
            -- Resolver Settings Sub-section
            local resolverSubSection = resolverToggle:settings({})
            
            -- Resolver Mode Dropdown
            resolverSubSection:dropdown({
                name = "Resolver Mode",
                flag = "silent_resolver_mode",
                items = {
                    "Velocity",
                    "MoveDirection", 
                    "CalculateCFrame"
                },
                default = "Velocity",
                callback = function(selected)
                    silentSettings.resolverMode = selected
                end,
                seperator = true
            })
            
            -- Main Loop
            run.RenderStepped:Connect(function()
                if fovFrame and silentSettings.showFov and silentSettings.useFov then
                    local mousePos = uis:GetMouseLocation()
                    fovFrame.Position = udim2_offset(mousePos.X, mousePos.Y - gui_offset)
                    fovFrame.Visible = true
                else
                    fovFrame.Visible = false
                end
                
                if not silentSettings.enabled then
                    destroyVisuals()
                    return
                end
                
                local target = getTarget()
                if target then
                    local predictedPosition = _G.silentUtility:predict(target, silentSettings.predictionX, silentSettings.predictionY)
                    if predictedPosition then
                        highlightPlayer(target)
                        updateTracer(predictedPosition)
                    else
                        destroyVisuals()
                    end
                else
                    destroyVisuals()
                end
            end)
            
            -- AIMBOT HOOK
            local __aimbot
            __aimbot = hookmetamethod(game, "__index", newcclosure(function(t, k)
                if t:IsA("Mouse") and (k == "Hit" or k == "Target") then
                    if not (silentSettings.enabled and getTarget()) then
                        return __aimbot(t, k)
                    end
                    
                    local target = getTarget()
                    if target then
                        local predictedPosition = _G.silentUtility:predict(target, silentSettings.predictionX, silentSettings.predictionY)
                        if predictedPosition then
                            local hit = cfr(predictedPosition)
                            return k == "Hit" and hit or target
                        end
                    end
                end
                return __aimbot(t, k)
            end))
            
        end
    end
end

-- // Visuals Tab  
do
    local VisualsTab = window:tab({
        name = "Visuals", 
        icon = "rbxassetid://10723346959"  -- lucide-eye
    })
    
    -- Visuals Section
    do
        local VisualsSection = VisualsTab:column({})
        local section = VisualsSection:section({name = "Visuals", default = false})
        
        -- Placeholder for visual features
        section:label({text = "Visual features will be added here"})
    end
end

-- // Misc Tab
do
    local MiscTab, LoadoutTab = window:tab({
        name = "Misc", 
        icon = "rbxassetid://10734934585",  -- lucide-rocket
        tabs = {"General", "Loadout"}
    })
    
    -- General Misc Section
    do
        local MiscSection = MiscTab:column({})
        local section = MiscSection:section({name = "General", default = false})
        
        -- Placeholder for misc features
        section:label({text = "Miscellaneous features will be added here"})
    end
    
    -- Loadout Section
    do
        local LoadoutSection = LoadoutTab:column({})
        local section = LoadoutSection:section({name = "Auto Buy", default = true})
        
        -- AutoArmor Toggle
        local autoArmorToggle = section:toggle({
            name = "Auto Armor",
            flag = "auto_armor_enabled",
            type = "toggle",
            callback = function(bool)
                _G.autoBuySettings.autoArmor.enabled = bool
            end
        })
        
        -- AutoArmor Settings
        local armorSettings = autoArmorToggle:settings({})
        
        armorSettings:keybind({
            name = "Auto Armor Key",
            flag = "auto_armor_key",
            key = enum.KeyCode.F1,
            mode = "Toggle",
            callback = function(active)
                library.config_flags["auto_armor_enabled"](active)
                _G.autoBuySettings.autoArmor.enabled = active
            end
        })
        
        armorSettings:slider({
            name = "Armor Value",
            flag = "auto_armor_value",
            min = 1,
            max = 129,
            default = 120,
            suffix = " HP",
            callback = function(value)
                _G.autoBuySettings.autoArmor.armorValue = value
            end,
            info = "Значение брони при котором будет покупаться новая броня"
        })
        
        -- AutoGuns Toggle
        local autoGunsToggle = section:toggle({
            name = "Auto Guns",
            flag = "auto_guns_enabled",
            type = "toggle",
            callback = function(bool)
                _G.autoBuySettings.autoGuns.enabled = bool
            end
        })
        
        -- AutoGuns Settings
        local gunsSettings = autoGunsToggle:settings({})
        
        gunsSettings:keybind({
            name = "Auto Guns Key",
            flag = "auto_guns_key",
            key = enum.KeyCode.F2,
            mode = "Toggle",
            callback = function(active)
                library.config_flags["auto_guns_enabled"](active)
                _G.autoBuySettings.autoGuns.enabled = active
            end
        })
        
        gunsSettings:dropdown({
            name = "Weapon Selection",
            flag = "auto_guns_weapon",
            items = {
                "[Rifle]", "[LMG]", "[P90]", "[Flintlock]", "[Revolver]", 
                "[Double-Barrel SG]", "[AK47]", "[TacticalShotgun]", 
                "[SMG]", "[AR]", "[Silencer]", "[Shotgun]"
            },
            default = {"[Rifle]", "[LMG]"},
            multi = true,
            callback = function(selectedWeapons)
                _G.autoBuySettings.autoGuns.selectedWeapons = selectedWeapons
                -- Update WEAPONS table to enable only selected weapons
                for _, weaponData in ipairs(_G.WEAPONS or {}) do
                    weaponData.Enabled = false
                    for _, selectedWeapon in ipairs(selectedWeapons) do
                        if weaponData.Name == selectedWeapon then
                            weaponData.Enabled = true
                            break
                        end
                    end
                end
            end,
            info = "Выберите оружие для автопокупки (можно несколько)"
        })
        
        -- AutoAmmo Toggle
        local autoAmmoToggle = section:toggle({
            name = "Auto Ammo",
            flag = "auto_ammo_enabled",
            type = "toggle",
            callback = function(bool)
                _G.autoBuySettings.autoAmmo.enabled = bool
            end
        })
        
        -- AutoAmmo Settings
        local ammoSettings = autoAmmoToggle:settings({})
        
        ammoSettings:keybind({
            name = "Auto Ammo Key",
            flag = "auto_ammo_key",
            key = enum.KeyCode.F3,
            mode = "Toggle",
            callback = function(active)
                library.config_flags["auto_ammo_enabled"](active)
                _G.autoBuySettings.autoAmmo.enabled = active
            end
        })
    end
end

-- // Settings Tab
do
    
    local SettingsTab, ConfigsTab = window:tab({
        name = "Settings", 
        icon = "rbxassetid://10734950309",  -- lucide-settings
        tabs = {"Main", "Configs"}
    })
    
    -- Settings Section
    do
        local SettingsSection = SettingsTab:column({})
        local section = SettingsSection:section({name = "Settings", default = false})
        
        -- Set default accent color
        library:update_theme("accent", rgb(0, 169, 255))
        
        -- Menu Keybind
        section:keybind({
            name = "Menu Keybind", 
            key = Enum.KeyCode.RightControl,
            mode = "Toggle",
            default = false,
            callback = function(bool) 
                window.toggle_menu(bool) 
            end,
            info = "Клавиша для открытия/закрытия меню"
        })
        
        -- Game Interaction Buttons
        section:button({
            name = "Copy JobId",
            callback = function()
                setclipboard(game.JobId)
                library.notifications:create_notification({
                    name = "JobId Copied",
                    info = "JobId copied to clipboard!",
                    lifetime = 3
                })
            end,
            info = "Copy current server JobId to clipboard"
        })
        
        section:button({
            name = "Copy GameID",
            callback = function()
                setclipboard(game.GameId)
                library.notifications:create_notification({
                    name = "GameID Copied",
                    info = "GameID copied to clipboard!",
                    lifetime = 3
                })
            end,
            info = "Copy current game ID to clipboard"
        })
        
        section:button({
            name = "Copy Join Script",
            callback = function()
                setclipboard(
                    'game:GetService("TeleportService"):TeleportToPlaceInstance(' ..
                        game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
                )
                library.notifications:create_notification({
                    name = "Join Script Copied",
                    info = "Join script copied to clipboard!",
                    lifetime = 3
                })
            end,
            info = "Copy teleport script to join this server"
        })
        
        section:button({
            name = "Rejoin",
            callback = function()
                game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, lp)
            end,
            info = "Rejoin current server"
        })
        
        section:button({
            name = "Join New Server",
            callback = function()
                local serverData = 
                    http_service:JSONDecode(
                    game:HttpGetAsync(
                        "https://games.roblox.com/v1/games/" ..
                            game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                    )
                )
                local validServers = {}
                for _, server in pairs(serverData.data) do
                    if server.playing >= library.flags["min_players"] and server.playing <= library.flags["max_players"] then
                        insert(validServers, server)
                    end
                end
                
                if #validServers > 0 then
                    local randomServer = validServers[random(1, #validServers)]
                    game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, randomServer.id)
                else
                    library.notifications:create_notification({
                        name = "No Servers Found",
                        info = "No servers found matching player count criteria!",
                        lifetime = 3
                    })
                end
            end,
            info = "Join a random server within player count range"
        })
        
        section:slider({
            name = "Min Players", 
            flag = "min_players", 
            min = 0, 
            max = 40, 
            default = 1, 
            interval = 1,
            info = "Minimum number of players required on server"
        })
        
        section:slider({
            name = "Max Players", 
            flag = "max_players", 
            min = 0, 
            max = 40, 
            default = 15, 
            interval = 1,
            info = "Maximum number of players allowed on server"
        })
        
        -- Notification Test Button
        section:button({
            name = "Notification Test", 
            callback = function()
                library.notifications:create_notification({
                    name = "Test Notification",
                    info = "This is a test notification with random colors!",
                    lifetime = 5
                })
            end
        })
    end
    
    -- Configs Section
    do
        local ConfigsSection = ConfigsTab:column({})
        local section = ConfigsSection:section({name = "Configs", default = true})
        
        local ConfigName = ""
        local ConfigSelected = ""
        
        -- Config List
        local configList = section:dropdown({
            name = "Configs",
            items = {"Default Config"},
            callback = function(selected)
                ConfigSelected = selected
                print("Config Selected:", selected)
            end,
            flag = "config_list"
        })
        
        -- Config Name Input
        section:textbox({
            name = "Config Name", 
            placeholder = "Enter config name...",
            callback = function(text)
                ConfigName = text
            end,
            flag = "config_name_input"
        })
        
        -- Create Config Button
        section:button({
            name = "Create Config", 
            callback = function()
                if ConfigName ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigName .. ".cfg"
                    if not isfile(configPath) then
                        writefile(configPath, library:get_config())
                        
                        -- Обновляем dropdown
                        local configFiles = {}
                        for idx, file in listfiles(library.directory .. "/configs") do
                            local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
                            insert(configFiles, name)
                        end
                        configList.refresh_options(configFiles)
                        
                        library.notifications:create_notification({
                            name = "Config Created",
                            info = "Config '" .. ConfigName .. "' created successfully!",
                            lifetime = 3
                        })
                    else
                        library.notifications:create_notification({
                            name = "Error",
                            info = "Config '" .. ConfigName .. "' already exists!",
                            lifetime = 3
                        })
                    end
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please enter a config name!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Load Config Button
        section:button({
            name = "Load Config", 
            callback = function()
                if ConfigSelected ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigSelected .. ".cfg"
                    if isfile(configPath) then
                        library:load_config(readfile(configPath))
                        library.notifications:create_notification({
                            name = "Config Loaded",
                            info = "Config '" .. ConfigSelected .. "' loaded successfully!",
                            lifetime = 3
                        })
                    else
                        library.notifications:create_notification({
                            name = "Error",
                            info = "Config file not found!",
                            lifetime = 3
                        })
                    end
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please select a config to load!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Save Config Button
        section:button({
            name = "Save Config", 
            callback = function()
                if ConfigSelected ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigSelected .. ".cfg"
                    writefile(configPath, library:get_config())
                    library.notifications:create_notification({
                        name = "Config Saved",
                        info = "Config '" .. ConfigSelected .. "' saved successfully!",
                        lifetime = 3
                    })
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please select a config to save!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Delete Config Button
        section:button({
            name = "Delete Config", 
            callback = function()
                if ConfigSelected ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigSelected .. ".cfg"
                    if isfile(configPath) then
                        delfile(configPath)
                        
                        -- Обновляем dropdown
                        local configFiles = {}
                        for idx, file in listfiles(library.directory .. "/configs") do
                            local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
                            insert(configFiles, name)
                        end
                        
                        if #configFiles > 0 then
                            configList.refresh_options(configFiles)
                        else
                            configList.refresh_options({"No configs found"})
                        end
                        
                        library.notifications:create_notification({
                            name = "Config Deleted",
                            info = "Config '" .. ConfigSelected .. "' deleted successfully!",
                            lifetime = 3
                        })
                        ConfigSelected = ""
                    else
                        library.notifications:create_notification({
                            name = "Error",
                            info = "Config file not found!",
                            lifetime = 3
                        })
                    end
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please select a config to delete!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Auto refresh function
        local function refreshConfigList(showNotification)
            local configFiles = {}
            for idx, file in listfiles(library.directory .. "/configs") do
                local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
                insert(configFiles, name)
            end
            
            if #configFiles > 0 then
                configList.refresh_options(configFiles)
            else
                configList.refresh_options({"No configs found"})
            end
            
            if showNotification then
                library.notifications:create_notification({
                    name = "Configs Refreshed",
                    info = "Config list updated!",
                    lifetime = 2
                })
            end
        end
        
        -- Auto refresh on startup
        refreshConfigList(false)
        
        -- Refresh Configs Button
        section:button({
            name = "Refresh Configs", 
            callback = function()
                refreshConfigList(true)
            end
        })
    end
end


library:update_theme("accent", rgb(0, 169, 255))
